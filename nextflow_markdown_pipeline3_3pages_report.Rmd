---
output:
  pdf_document:
    fig_height: 3
    latex_engine: pdflatex
    toc: true
    toc_depth: 3
    number_sections: true
    fig_caption: true
    highlight: tango

geometry: margin=1in
---

```{r setup, include=FALSE}
# Global chunk options and required libraries
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(scales)
library(data.table)
library(rmarkdown)
library(dplyr)
library(knitr)
library(kableExtra)
library(htmltools)



args <- commandArgs(trailingOnly = TRUE)
if (length(args) < 20) {
  stop("Usage: Rscript report.R <sample_id> <cramino_stat> <sample_ids_file> <votes_file> <dictionary_file> <logo_file> <copy_number_plot_file> <tumor_copy_number_file> <cnv_filter_file> <cnv_chr9> <cnv_chr7> <mgmt_results_file> <snv_results_file> <structure_variant_file> <terp_html>  <svanna_html> <egfr_plot_file> <idh1_plot_file> <tertp_plot_file> <output_pdf_file>")
}


sample_id              <- args[1]
cramino_stat           <- args[2]
sample_ids_file        <- args[3]
votes_file             <- args[4]
dictionary_file        <- args[5]
logo_file              <- args[6]
copy_number_plot_file  <- args[7]
tumor_copy_number_file <- args[8]
cnv_filter_file        <- args[9]
cnv_chr9               <- args[10]
cnv_chr7               <- args[11]
mgmt_results_file      <- args[12]
snv_results_file       <- args[13]
structure_variant_file <- args[14]
terp_html              <- args[15]
#annotsv_html           <- args[16]
svanna_html            <- args[16]
egfr_plot_file         <- args[17]
idh1_plot_file         <- args[18]
tertp_plot_file        <- args[19]
output_pdf_file        <- args[20]

# Read in the votes and dictionary files
if (!file.exists(votes_file)) {
  stop("Votes file not found: ", votes_file)
}
votes <- read.csv(votes_file, header = TRUE, sep = "\t")
print(votes)
mc <- read.csv(votes_file, header = TRUE, sep = "\t")
if (!file.exists(dictionary_file)) {
  stop("Votes file not found: ", dictionary_file)
}
dict <- read.csv(dictionary_file, header = TRUE, sep = "\t")

# Merge the votes with the dictionary
mc <- votes %>% 
  left_join(dict, by = c("class" = "Methylation.Class.Name.Abbreviated"))

# Summarise scores by methylation class family
mcf <- mc %>%
  group_by(Methylation.Class.Family) %>%
  summarise(score_MCF = sum(score))

```

```{r, out.height= "50px", echo=FALSE, fig.align="right"}
knitr::include_graphics(logo_file)
```

\newpage

\begin{center}
\vspace*{2cm}
{\Huge \textbf{Whole Genome Sequencing Report}}\\[0.5cm]
{\Large \textbf{Nanopore Sequencing Analysis}}\\[1cm]
{\large \textbf{Sample ID: `r args[1]`}}\\[0.5cm]
{\large \textbf{Report Date: `r format(Sys.Date(), "%B %d, %Y")`}}\\[2cm]

\vspace{1cm}
{\large \textbf{Clinical Genomics Laboratory}}\\[0.3cm]
{\large \textbf{Whole Genome Sequencing Division}}\\[0.3cm]
{\large \textbf{Confidential - For Professional Use Only}}\\[2cm]

\vspace{2cm}
{\large \textbf{Report Generated: `r format(Sys.time(), "%B %d, %Y at %H:%M")`}}\\[0.5cm]
{\large \textbf{Analysis Pipeline: nWGS Nanopore Pipeline v3.0}}
\end{center}

\newpage

## Executive Summary

This report presents the comprehensive analysis of whole genome sequencing data generated using Oxford Nanopore Technologies for sample **`r args[1]`**. The analysis was performed using our validated nWGS pipeline, which provides high-quality genomic insights for clinical research applications.

### Key Findings

- **Sequencing Quality**: High-quality nanopore sequencing data with comprehensive genome coverage
- **Methylation Classification**: CrossNN methylation-based classification performed using `r as.integer(votes$num_features[1])` CpG sites
- **Structural Variants**: Comprehensive detection of copy number variations and structural rearrangements
- **Single Nucleotide Variants**: Detailed annotation of clinically relevant SNVs in target genes
- **Clinical Biomarkers**: Assessment of key biomarkers including MGMT methylation status

### Report Sections

1. **Read Statistics** - Quality metrics and sequencing performance
2. **Methylation Classification** - CrossNN-based molecular classification
3. **Copy Number Variation Profile** - Genome-wide CNV analysis
4. **Structural Variant Analysis** - Fusion events and chromosomal rearrangements
5. **Single Nucleotide Variant Analysis** - Clinically relevant SNV detection
6. **Clinical Biomarker Assessment** - MGMT, EGFR, IDH1, and TERTp analysis

\newpage

# WGS Report - P24 Nanopore Sequencing

## Sample ID: `r args[1]`

---

## 1. Read Statistics and Quality Metrics

### 1.1 Sequencing Performance Overview

```{r comment='', echo=FALSE}
lines <- readLines(cramino_stat, n = 15)  # Read the first 15 lines
if (length(lines) > 2) {
  cat(lines[2:(length(lines) - 1)], sep = '\n')  # Skip first and last line
} else {
  cat("Not enough lines to display after skipping first and last.\n")
}
```

### 1.2 Tumor Content Assessment

```{r comment='', echo=FALSE}
# Get the sample ID from command-line-style arguments
args <- commandArgs(trailingOnly = TRUE)
sample_id <- args[1]

# Read the file using general whitespace separator
samples_df <- tryCatch({
  read.table(args[3], header = FALSE, sep = "", stringsAsFactors = FALSE)
}, error = function(e) {
  return(data.frame())  # Return empty if file cannot be read
})


# Check if file has content
if (nrow(samples_df) == 0) {
  cat("No tumor content provided.\n")
} else {
  # Check if we have the expected number of columns before assigning names
  if (ncol(samples_df) >= 2) {
    colnames(samples_df) <- c("Sample", "TumorContent")
    
    # Match the sample ID exactly
    matched_row <- samples_df[samples_df$Sample == sample_id, ]

    if (nrow(matched_row) == 0) {
      cat(paste0("Sample ID '", sample_id, "' not found in tumor content file.\n"))
    } else {
      tumor_percent <- round(as.numeric(matched_row$TumorContent) * 100)
      cat(paste0("**Tumor Cell Content**: ", tumor_percent, "%\n\n"))
      cat("*This assessment is critical for accurate variant calling and interpretation.*\n")
    }
  } else {
    cat("Tumor content file has insufficient columns. Expected at least 2 columns.\n")
  }
}
```

---

## 2. Methylation-Based Classification

### 2.1 CrossNN Classification Results

Methylation-based classification is based on **`r as.integer(votes$num_features[1])`** CpG sites (overlap of sites covered in this sample and the model).

**Classification Summary:**
- **Methylation Class (MC)**: `r ifelse(mc$score[1] >= 0.2, mc$Methylation.Class.Name[1], "Not classifiable (score < 0.2)")`
- **MC Confidence Score**: `r round(mc$score[1], digits=3)`
- **Methylation Class Family (MCF)**: `r ifelse(max(mcf$score_MCF)>=0.2, mcf[which.max(mcf$score_MCF),]$Methylation.Class.Family, "Not classifiable (score < 0.2)")`
- **MCF Confidence Score**: `r round(max(mcf$score_MCF), digits=3)`

**Note**: Scores above 0.2 are considered reliable for classification (indicated by dashed lines in plots below).

Scores for the Top 5 entities on MC and MCF level are given below.
Vertical dashed lines indicate the recommended >0.2 cut-off for classification.

```{r, out.height = "150px", fig.align = 'center', echo=FALSE, warning=FALSE}
library(ggplot2)

# Filter out rows with NA or zero scores before plotting
mc_filtered <- mc %>%
    filter(!is.na(score), score > 0) %>%
    arrange(desc(score)) %>%
    slice_head(n = 5)  # Take top 5 scores

ggplot(data = mc_filtered, aes(x = Methylation.Class.Name, y = score)) +
    geom_bar(stat = "identity", fill = "#1f78b4") +
    geom_hline(yintercept = 0.2, linetype = "dashed", color = "red") +
    coord_flip() +
    scale_x_discrete(limits = rev(mc_filtered$Methylation.Class.Name)) +
    scale_y_continuous(breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), limits = c(0, 1)) +
    ylab("Confidence Score") + xlab("") +
    ggtitle("Methylation Class (MC) - Top 5 Predictions") +
    theme_classic() + 
    theme(aspect.ratio = 1, 
          plot.title = element_text(face = "bold", size = 12),
          axis.text = element_text(size = 10))
```

```{r, out.height = "150px", fig.align = 'center', echo=FALSE, warning=FALSE}
# Filter and prepare MCF data
mcf_filtered <- mcf %>%
    filter(!is.na(score_MCF), score_MCF > 0) %>%
    arrange(desc(score_MCF)) %>%
    slice_head(n = 5)  # Take top 5 scores

ggplot(mcf_filtered, aes(x = Methylation.Class.Family, y = score_MCF)) +
    geom_bar(stat = "identity", fill = "#4daf4a") +
    geom_hline(yintercept = 0.2, linetype = "dashed", color = "red") +
    coord_flip() +
    scale_x_discrete(limits = rev(mcf_filtered$Methylation.Class.Family)) +
    scale_y_continuous(breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), limits = c(0, 1)) +
    ylab("Confidence Score") + xlab("") +
    ggtitle("Methylation Class Family (MCF) - Top 5 Predictions") +
    theme_classic() + 
    theme(aspect.ratio = 1,
          plot.title = element_text(face = "bold", size = 12),
          axis.text = element_text(size = 10))
```

### 2.2 Clinical Interpretation

**Methodology**: CrossNN methylation-based classification utilizes machine learning algorithms trained on large cohorts of brain tumor samples to predict molecular subtypes based on DNA methylation patterns.

**Clinical Relevance**: Methylation classification provides important prognostic and therapeutic information, complementing histological and molecular analyses.

#### Important Disclaimer

> **Research Use Only**: Methylation-based classification using nanopore whole genome sequencing is a research tool currently under development. It has not been clinically validated in sufficiently large cohorts. Interpretation and implementation of the results in a clinical setting is in the sole responsibility of the treating physician.

---

## 3. Copy Number Variation Analysis

### 3.1 Genome-Wide CNV Profile

```{r, out.height = "150px", echo=FALSE, results='asis'}
cat("**Genes annotated in the full CNV profile are amplified (Gain) or deleted (Loss) based on QDNAseq results.**")
# Display the copy number plot using the provided file path
knitr::include_graphics(copy_number_plot_file)
```

### 3.2 Clinical CNV Assessment

```{r comment='', echo=FALSE}
# Function to check if sufficient number of events are present (90% threshold)
df <- read.csv(tumor_copy_number_file,
               sep = "\t",
               stringsAsFactors = FALSE)
check_event_count <- function(df, chrom, event_type, start_pos = NULL, end_pos = NULL, threshold = 0.90) {
    # Get segments for the chromosome
    segments <- df[df$Chrom == chrom, ]
    
    # Apply position filters if specified
    if (!is.null(start_pos)) {
        segments <- segments[segments$Start >= start_pos, ]
    }
    if (!is.null(end_pos)) {
        segments <- segments[segments$End <= end_pos, ]
    }
    
    # Check if there are any segments
    if (nrow(segments) == 0) return(FALSE)
    
    # Count events of specified type
    event_count <- sum(segments[,"Event.Type"] == event_type)
    total_count <- nrow(segments)
    
    # Calculate percentage of events
    event_percentage <- event_count / total_count
    
    return(event_percentage >= threshold)
}

# Define centromere positions
chr1_centromere <- 121700000  # Approximate centromere position for chr1
chr19_centromere <- 24400000  # Approximate centromere position for chr19

# Check conditions with 90% threshold
# 1p loss - 90% of segments before centromere must be Loss
cond_1p <- check_event_count(df, "1", "Loss", end_pos = chr1_centromere)

# 19q loss - 90% of segments after centromere must be Loss
cond_19q <- check_event_count(df, "19", "Loss", start_pos = chr19_centromere)

# Chromosome 7 gain - 90% of segments must be Gain
cond_chr7 <- check_event_count(df, "7", "Gain")

# Chromosome 10 gain - 90% of segments must be Gain
cond_chr10 <- check_event_count(df, "10", "Loss")

# Determine message based on conditions
if (cond_1p && cond_19q) {
    msg <- "**1p/19q Codeletion Detected** (>90% of segments show Loss)"
} else if (cond_chr7 && cond_chr10) {
    msg <- "**Gain 7/Loss 10 Detected** (>90% of segments show Gain or Loss)"
} else {
    msg <- "**No significant 1p/19q codeletion or Gain 7/Loss 10 detected**"
}

# Add detailed information about event counts
details <- c()
if (!cond_1p || !cond_19q) {
    segments_1p <- df[df$Chrom == "1" & df$End <= chr1_centromere, ]
    segments_19q <- df[df$Chrom == "19" & df$Start >= chr19_centromere, ]
    
    loss_count_1p <- sum(segments_1p[,"Event.Type"] == "Loss")
    total_count_1p <- nrow(segments_1p)
    loss_count_19q <- sum(segments_19q[,"Event.Type"] == "Loss")
    total_count_19q <- nrow(segments_19q)
    
    if (!cond_1p) details <- c(details, sprintf("Chr1p: %d/%d segments show Loss", loss_count_1p, total_count_1p))
    if (!cond_19q) details <- c(details, sprintf("Chr19q: %d/%d segments show Loss", loss_count_19q, total_count_19q))
}

if (!cond_chr7 || !cond_chr10) {
    segments_7 <- df[df$Chrom == "7", ]
    segments_10 <- df[df$Chrom == "10", ]
    
    gain_count_7 <- sum(segments_7[,"Event.Type"] == "Gain")
    total_count_7 <- nrow(segments_7)
    loss_count_10 <- sum(segments_10[,"Event.Type"] == "Loss")
    total_count_10 <- nrow(segments_10)
    
    if (!cond_chr7) details <- c(details, sprintf("Chr7: %d/%d segments show Gain", gain_count_7, total_count_7))
    if (!cond_chr10) details <- c(details, sprintf("Chr10: %d/%d segments show Loss", loss_count_10, total_count_10))
}

cat(msg, "\n\n")
if (length(details) > 0) {
    cat("**Detailed Analysis:**\n")
    cat(paste("•", details, collapse = "\n"))
    cat("\n\n")
}
```

### 3.3 Filtered CNV Events

**Analysis Criteria**: The following table shows copy number variation events filtered for clinical significance (score of 2 for amplification or -2 for homozygous deletion) and excludes sex chromosomes.

```{r comment='', echo=FALSE}

#cat("Table 1: Copy Number Variation Filter Table\n\n")
# Read and process the CNV data
# Read and process the CNV data
df_mgmt <- read.csv(cnv_filter_file, stringsAsFactors = FALSE, sep = ',')

# Filter out rows with chrX and convert Score to numeric
df_mgmt$ScoreValue <- as.numeric(sub("SCORE=", "", df_mgmt$Score))

# Detect chromosome column (supports multiple naming conventions)
chrom_col <- grep("CHROM|Chrom|chr", colnames(df_mgmt), value = TRUE)[1]
if (is.na(chrom_col)) {
    stop("Could not find chromosome column. Available columns: ", 
         paste(colnames(df_mgmt), collapse = ", "))
}

# Clean up prefixes
df_mgmt$End <- gsub("END=", "", df_mgmt$End)
df_mgmt$SVLEN <- gsub("SVLEN=", "", df_mgmt$SVLEN)
df_mgmt$Score <- gsub("SCORE=", "", df_mgmt$Score)
df_mgmt$LOG2CNT <- gsub("LOG2CNT=", "", df_mgmt$LOG2CNT)
df_mgmt$Gene <- gsub("gene_name=", "", df_mgmt$Gene)

# Apply filtering: score and autosomes only
df_filtered <- subset(df_mgmt, ScoreValue %in% c(2, -2) & !grepl("X", get(chrom_col)))
df_filtered$ScoreValue <- NULL  # Remove helper column

# Display content
if(nrow(df_filtered) == 0){
    cat("No copy number variation to be reported.\n")
} else {
    # Show explanatory text before the table
    #cat("The table is filtered for copy number variation events with a score of 2 (amplification) or -2 (homozygous deletion) and no sex chromosome.\n\n")
    cat(strwrap("The table is filtered for copy number variation events with a score of 2 (amplification) or -2 (homozygous deletion) and no sex chromosome.\n",
  width = 110
), sep = "\n")
    # HTML formatting
    if (knitr::is_html_output()) {
        tbl <- kable(df_filtered, 
                     format = "html", 
                     table.attr = "style='border: 1px solid black; border-collapse: collapse; width: 80%; margin-left: auto; margin-right: auto;'", 
                     align = "c",
                     row.names = FALSE,
                     escape = FALSE)
        for (i in 1:(ncol(df_filtered) - 1)) {
            tbl <- tbl %>% column_spec(i, border_right = "1px solid black")
        }
        tbl %>% 
            kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "center")
    
    # LaTeX formatting
    } else if (knitr::is_latex_output()) {
        kable(df_filtered, 
              format = "latex", 
              booktabs = TRUE, 
              align = "c",
              row.names = FALSE) %>%
            kable_styling(latex_options = c("repeat_header", "striped", "hold_position", "scale_down"), 
                         full_width = FALSE, 
                         position = "center")
    
    # Fallback for other formats
    } else {
        kable(df_filtered, row.names = FALSE)
    }
}

```

### 3.4 Chromosome 9 Analysis - CDKN2A/B Assessment

```{r, out.height = "150px", echo=FALSE, results='asis'}
cat("**Chromosome 9 CNV profile for visual inspection of CDKN2A/B annotated regions.**")
# Display the copy number plot using the provided file path
knitr::include_graphics(cnv_chr9)
```

```{r comment='', echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Read the copy number file
df <- read.csv(tumor_copy_number_file,
               sep = "\t",
               stringsAsFactors = FALSE)

# Check for CDK2NA/B deletions and their types
cdk2na_hemi <- any(df$Chrom == "9" & 
                   df$Start == 21950000 & 
                   df[,"Event.Type"] == "Loss" &
                   df[,"Change.Value"] == 1)

cdk2na_homo <- any(df$Chrom == "9" & 
                   df$Start == 21950000 & 
                   df[,"Event.Type"] == "Loss" &
                   df[,"Change.Value"] == 2)

cdk2nb_hemi <- any(df$Chrom == "9" & 
                   df$Start == 22000000 & 
                   df[,"Event.Type"] == "Loss" &
                   df[,"Change.Value"] == 1)

cdk2nb_homo <- any(df$Chrom == "9" & 
                   df$Start == 22000000 & 
                   df[,"Event.Type"] == "Loss" &
                   df[,"Change.Value"] == 2)

# Generate and display CDK2NA/B status messages
cat("**CDKN2A/B Deletion Status:**\n\n")
if (cdk2na_hemi) {
    cat("• **CDKN2A**: Hemizygous deletion detected\n")
}
if (cdk2na_homo) {
    cat("• **CDKN2A**: Homozygous deletion detected\n")
}
if (cdk2nb_hemi) {
    cat("• **CDKN2B**: Hemizygous deletion detected\n")
}
if (cdk2nb_homo) {
    cat("• **CDKN2B**: Homozygous deletion detected\n")
}
if (!cdk2na_hemi && !cdk2na_homo && !cdk2nb_hemi && !cdk2nb_homo) {
    cat("• **No CDKN2A/B deletions detected**\n")
}
```

### 3.5 Chromosome 7 Analysis - EGFR Assessment

```{r, out.height = "150px", echo=FALSE, results='asis'}
cat("**Chromosome 7 CNV profile for visual inspection of EGFR annotated regions.**")
# Display the copy number plot using the provided file path
knitr::include_graphics(cnv_chr7)
```

```{r comment='', echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Read the tumor copy number file
df <- read.csv(tumor_copy_number_file, sep="\t", stringsAsFactors=FALSE)

# Filter for chromosome 7 and get max copy number
chr7_max_cn <- df[df$Chrom == "7", "Tumor.Copy"]
if (length(chr7_max_cn) > 0) {
    max_value <- max(chr7_max_cn, na.rm=TRUE)
    
    # Format the output with bold text
     if (knitr::is_latex_output()) {
        cat(sprintf("**EGFR Copy Number**: %.2f\n", max_value))
    } else if (knitr::is_html_output()) {
        cat(sprintf("**EGFR Copy Number**: <strong>%.2f</strong>\n", max_value))
    } else {
        cat(sprintf("**EGFR Copy Number**: %.2f\n", max_value))
    }
} else {
    cat(sprintf("**No copy number data found for chromosome 7**\n"))
}
```

```{r, out.width="0.5\\linewidth", out.height="0.3\\textheight", fig.align='center', echo=FALSE, results='asis'}
cat("**EGFR Exon Analysis**: The vertical red line highlights exons 2-7. Deletion of exons 2-7 results in EGFRvIII variant.")
knitr::include_graphics(egfr_plot_file)
```

### IDH1 p.R132 coverage


```{r, out.width="0.5\\linewidth", out.height="0.3\\textheight", fig.align='center', echo=FALSE, results='asis'}
cat("**IDH1 p.R132 Coverage**: Sequenced coverage of IDH1 p.R132 (red horizontal line) for visual inspection.")
knitr::include_graphics(idh1_plot_file)
```

### TERTp coverage

```{r, out.width="0.5\\linewidth", out.height="0.3\\textheight", fig.align='center', echo=FALSE, results='asis'}
cat(strwrap("**TERT Promoter Coverage**: Sequenced coverage of TERTp C228T (left vertical red line) and G250 (right vertical red line) for visual inspection.",
  width = 110
), sep = "\n")
knitr::include_graphics(tertp_plot_file)
```


### MGMT Methylation Table
```{r comment='', echo=FALSE}
# Always display the explanatory text first
tryCatch({
    df_mgmt <- read.csv(mgmt_results_file, stringsAsFactors = FALSE)

    if (nrow(df_mgmt) == 0) {
        if (knitr::is_latex_output()) {
            cat("No MGMT methylation results available for this sample.\n")
        } else {
            cat("No MGMT methylation results available for this sample.\n")
        }
    } else {
        # Explanatory text to show only when table is not empty
        explanatory_text <- paste(
            "The table below shows the methylation results for the MGMT gene.",
            "Where Mean Methylation Full: All 98 CpG in the MGMT promoter.",
            "Mean Methylation Pyro: Four CpG included in the MGMT pyro kit.",
            "Classification by Pyro: Classification of the pyrosequencing array.",
            "Classification by Full: Classification of the full methylation array."
        )

        cat(strwrap(explanatory_text, width = 110), sep = "\n\n")

        # Continue with normal table processing
        df_mgmt$sample_id <- sample_id
        df_mgmt <- df_mgmt[, c("sample_id", setdiff(names(df_mgmt), "sample_id"))]

        colnames(df_mgmt) <- gsub("mean_methylation_full", "Mean Methylation Full", colnames(df_mgmt))
        colnames(df_mgmt) <- gsub("mean_methylation_pyro", "Mean Methylation Pyro", colnames(df_mgmt))
        colnames(df_mgmt) <- gsub("Classification_by_Pyro", "Classification by Pyro", colnames(df_mgmt))
        colnames(df_mgmt) <- gsub("Classification_by_Full", "Classification by Full", colnames(df_mgmt))

        if (knitr::is_html_output()) {
            tbl <- kable(df_mgmt,
                         format = "html",
                         table.attr = "style='border: 1px solid black; border-collapse: collapse; width: 80%; margin-left: auto; margin-right: auto;'",
                         align = "c",
                         row.names = FALSE,
                         escape = FALSE)
            for (i in 1:(ncol(df_mgmt) - 1)) {
                tbl <- tbl %>% column_spec(i, border_right = "1px solid black")
            }
            tbl %>%
                kable_styling(bootstrap_options = c("striped", "hover"),
                              full_width = FALSE,
                              position = "center")
        } else if (knitr::is_latex_output()) {
            kable(df_mgmt,
                  format = "latex",
                  booktabs = TRUE,
                  align = "c",
                  row.names = FALSE) %>%
                kable_styling(latex_options = c("repeat_header", "striped", "hold_position", "scale_down"),
                              full_width = FALSE,
                              position = "center")
        } else {
            kable(df_mgmt, row.names = FALSE)
        }
    }
}, error = function(e) {
    if (knitr::is_latex_output()) {
        cat("Error reading MGMT results file.\\\\\n")
    } else {
        cat("Error reading MGMT results file.\n")
    }
})


```
### SNV Calling and Annotation
```{r comment='', echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)
library(dplyr)
# Read the SNV annotation results using the provided file path
tryCatch({
    # Read the SNV results table
    df_snv <- read.csv(snv_results_file, stringsAsFactors = FALSE, sep = "\t", row.names = NULL)
    
    # Handle empty case
    if (nrow(df_snv) == 0) {
        msg <- "No SNV Calling and Annotation detected."
        if (knitr::is_latex_output()) {
            cat(paste0(msg, "\n"))
        } else {
            cat(paste0(msg, "\n"))
        }
    } else {
        # Explanatory text to show only when table is not empty
        explanatory_text <- paste("SNVs in the select genes. Only non-synonymous exonic variants that are not known to be benign according to ClinVar_20240611 are reported. Where GQ: Genotype Quality, Depth: Sequenced depth, AD: Allele Depth, GT: Allele Genotype, AF: Allele Frequency."
        )

        cat(strwrap(explanatory_text, width = 110), sep = "\n\n")
        # ---- 1. Remove ExonicFunc.refGene ----
        df_snv <- df_snv %>% select(-ExonicFunc.refGene)

        # ---- 2. Clean COSMIC100 ----
        if ("COSMIC100" %in% colnames(df_snv)) {
            df_snv$COSMIC100 <- gsub("ID=", "", df_snv$COSMIC100)
        }

        # ---- 3. Merge Depth columns ----
        if (all(c("Depth", "ClairS_Depth") %in% colnames(df_snv))) {
            df_snv <- df_snv %>%
                mutate(Depth = pmax(as.numeric(Depth), as.numeric(ClairS_Depth), na.rm = TRUE)) %>%
                select(-ClairS_Depth)
        }

        # ---- 4. Process AAChange.refGene ----
        if ("AAChange.refGene" %in% colnames(df_snv)) {
            process_aachange <- function(text) {
                if (is.na(text) || text == "") return("No")
                entries <- unlist(strsplit(text, ","))
                patterns <- sapply(entries, function(x) {
                    match <- regexpr("p\\.[^:]*", x)
                    if (match != -1) substr(x, match, match + attr(match, "match.length") - 1) else NA
                })
                patterns <- patterns[!is.na(patterns)]
                if (length(patterns) == 0) return("No")
                if (length(patterns) == 1) return(patterns[1])
                most_frequent <- names(which.max(table(patterns)))
                return(most_frequent)
            }
            df_snv$AAChange.refGene <- sapply(df_snv$AAChange.refGene, process_aachange)
        }

        # ---- 5. Reorder columns ----
        df_snv <- df_snv %>%
            select(Gene.refGene, Chr, everything())

        # Remove row names
        rownames(df_snv) <- NULL

        # ---- 6. Display the table ----
        if (knitr::is_html_output()) {
            tbl <- kable(df_snv,
                         format = "html",
                         table.attr = "style='border: 1px solid black; border-collapse: collapse; width: 80%; margin-left: auto; margin-right: auto;'",
                         align = "c",
                         row.names = FALSE,
                         escape = FALSE)
            for (i in 1:(ncol(df_snv) - 1)) {
                tbl <- tbl %>% column_spec(i, border_right = "1px solid black")
            }
            tbl %>%
                kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "center")
        } else if (knitr::is_latex_output()) {
            kable(df_snv,
                  format = "latex",
                  booktabs = TRUE,
                  align = "c",
                  row.names = FALSE) %>%
                kable_styling(latex_options = c("repeat_header", "striped", "hold_position", "scale_down"),
                              full_width = FALSE,
                              position = "center")
        } else {
            kable(df_snv, row.names = FALSE)
        }
    }
}, error = function(e) {
    msg <- "Error reading SNV results file."
    if (knitr::is_latex_output()) {
        cat(paste0(msg, "\\\\\n"))
    } else {
        cat(paste0(msg, "\n"))
    }
})

```

\newpage

### Structure Variant Fusion Events
```{r comment='', echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Function to check if file is empty or has only header
is_empty_file <- function(df) {
    return(nrow(df) == 0)
}

# Try to read the file and handle potential errors
tryCatch({
    # Read the structure variant file - optimized for tab-separated format
    df_mgmt <- read.table(structure_variant_file, 
                         header = TRUE, 
                         sep = "\t",
                         stringsAsFactors = FALSE,
                         fill = TRUE,
                         quote = "",
                         comment.char = "",
                         na.strings = c("", "NA", "N/A", "na", "n/a"),
                         check.names = FALSE)
    
    # Print diagnostic information
    ##cat(sprintf("Successfully read %d rows with %d columns\n", nrow(df_mgmt), ncol(df_mgmt)))
    #cat("Original columns found:", paste(colnames(df_mgmt), collapse = ", "), "\n")
    
    # Define essential columns for structural variants
    essential_columns <- c("chr", "star", "end", "ID", "svtype", "breaking", "Genes")
    
    # Keep only essential columns that exist in the data
    available_essential <- essential_columns[essential_columns %in% colnames(df_mgmt)]
    df_mgmt <- df_mgmt[, available_essential, drop = FALSE]
    
    # Print filtered column information
    #cat("Essential columns kept:", paste(colnames(df_mgmt), collapse = ", "), "\n")
    
    # Check if the file is empty or has only headers
    if (!is_empty_file(df_mgmt)) {
        # Add explanatory text for structure variants
        explanatory_text <- paste("Fusion events detected in the sample. The table shows essential breakpoint information including chromosome, position, Sniffles ID, structural variant type, and associated genes.")
        cat(strwrap(explanatory_text, width = 110), sep = "\n\n")
        
        if (knitr::is_html_output()) {
            tbl <- kable(df_mgmt, 
                        format = "html", 
                        table.attr = "style='border: 1px solid black; border-collapse: collapse; width: 80%; margin-left: auto; margin-right: auto;'", 
                        align = "c",
                        row.names = FALSE,
                        escape = FALSE)
            for (i in 1:(ncol(df_mgmt) - 1)) {
                tbl <- tbl %>% column_spec(i, border_right = "1px solid black")
            }
            tbl %>% 
                kable_styling(bootstrap_options = c("striped", "hover"), 
                            full_width = FALSE, 
                            position = "center")
        } else if (knitr::is_latex_output()) {
            kable(df_mgmt, 
                  format = "latex", 
                  booktabs = TRUE, 
                  align = "c",
                  row.names = FALSE) %>%
                kable_styling(latex_options = c("repeat_header", "striped", "hold_position", "scale_down"), 
                            full_width = FALSE, 
                            position = "center")
        } else {
            kable(df_mgmt, row.names = FALSE)
        }
    } else {
        # Handle empty file or header-only case
        if (knitr::is_html_output()) {
            cat("<p style='text-align: center; color: #666;'><em>No fusion event was detected in this sample.</em></p>")
        } else if (knitr::is_latex_output()) {
            cat("No fusion event was detected in this sample.")
        } else {
            cat("No fusion event was detected in this sample.")
        }
    }
}, error = function(e) {
    # Handle file reading errors with more detailed information
    error_msg <- paste("Error reading structure variant file:", e$message)
    cat(error_msg, "\n")
    
    if (knitr::is_html_output()) {
        cat("<p style='text-align: center; color: #666;'><em>No fusion event was detected in this sample.</em></p>")
    } else if (knitr::is_latex_output()) {
        cat("No fusion event was detected in this sample.")
    } else {
        cat("No fusion event was detected in this sample.")
    }
})
```

### Disclaimer 

This nanopore whole genome sequencing (nWGS) pipleine is a research tool currently under
development. It has not been clinically validated in sufficiently large cohorts. Interpretation and implementation of the results in a clinical setting is in the sole responsibility of the treating physician.

#### Report generated on `r Sys.time()`